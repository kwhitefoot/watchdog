#!/bin/bash

#===================================================================

# Purpose:

# I have a Python script that uploads to flickr.  On my netbook it
# fails to resume when the machine comes out of suspend.  Experiments
# show that sleep does not suffer from this problem so a watxhdog can
# be created.

# The Python script is inherently restartable so it is safe to kill it
# and restart.

#--------------------------------------------

# Method:
# start the process
# touch the activity file
# Forever:
#   find activity file that has not changed 
#   If found:
#      kill all child processes (this means that we do not need to
#                                record the pid of the child and risk
#                                pid recycling)
#      sleep 1
#      start the process
#      sleep interval
#   endif
# loop

# The file used to detect activity can be a file that the process
# touches as part of its normal operations or the process can be
# written deliberately to touch a file at intervals for just this
# purpose.

# The watchdog takes arguments specifying:
# - the path to the process to be started, 
# - path to the activity file,
# - the sleep time in whole minutes

# where the command line can be anything but remember that ~ will not
# be expanded if you quote it and that you will probably need to quote
# it unless it is a bare command with no arguments; use ${HOME}
# instead.  The same applies to the path to the activity file.

#---------------------------------------------------------------------
# Author: Kevin Whitefoot <kwhitefoot@hotmail.com>
# Created: 2014-01-14

#---------------------------------------------------------------------
# Prerequisites:

# bash: Should be trivial to rewrite for other shells, especially bsh
#       and sh.

# date: only used for timestamping

# find, grep: These are the tools that do the real work.

#===================================================================

#set -x
#set -e


print ()
{
    echo "watchdog: $(date +'%F %T')"
    echo "watchdog: $1"
}

# Kill subprocess on exit.
trap_exit () 
{
    echo ""
    print "Terminating process"
    pkill -P $$
}

trap trap_exit EXIT

show_usage_and_exit ()
{
    cat <<EOF
watchdog, version 1.0
Usage: watchdog command activity interval
Where:
  command is a command line to be executed.  Use quotes if it includes spaces
  activity is a file to be monitored
  interval is the number of minutes between checks.

This command executes the specified command and then loops checking to
see if a file changes.  If the file does not change within the
specified interval we kill the process and restart it and continue
checking.

If the command exits normally it will still be restarted as long as the activity file mtime does not change within the interval.

Report bugs to kwhitefoot@hotmail.com.
EOF
    
    exit 1
}


# Check args
if (( $# != 3 )); then
    show_usage_and_exit
fi

# Name the arguments
cmd=$1
activity=$2
sleep_time=$3

if [ "$sleep_time" -eq "$sleep_time" ] 2>/dev/null; then
    print "Sleep time $sleep_time minutes"
else
    print "Sleep time must be an integer number of minutes"
    show_usage_and_exit
fi

# Initialize the watched file
touch "${activity}"

# Start the process and check that it is running.  Abort if we cannot start.
start_process ()
{
    print "starting the process"
    ${cmd} &
    pgrep -P $$
    if [ "$?" -ne "0" ]; then
        print "failed to start process"
        show_usage_and_exit
    fi
}

start_process

while [ 1 ]
do
    print "Looking for inactivity"
    if find "${activity}" -mmin +$sleep_time | grep ".*" 
    then
        # Activity file has not changed in the given interval.  This
        # means that either the program is hanging or that it has
        # crashed.  Of course it can also mean that it has exited
        # normally.

        # Kill our children.  This is better than using the pid of the
        # process that we launch because the id could be re-used.
        print "Killing hung process"
        pkill -P $$     # Actually kill all processes of which this is
                        # the parent which avoids needing to know the
                        # child pid and avoids the risk of pid
                        # recycling.

	sleep 1       	# Lot's of people recommend this, not sure if
                        # it is really necessary.

        start_process
    fi
    print "sleeping ..."
    sleep "${sleep_time}m"
done
